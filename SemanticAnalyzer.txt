#include <set>
#include "SemanticAnalyzer.h"
#include "SymbolTableBuilder.h"
#include "SymbolTable.h"

#include <iostream>

using namespace std;

void performSemanticAnalysis(Node* root, SymbolTable& table) {
    if (!root) {
        cerr << "Semantic Analysis Error: AST root is null!" << endl;
        return;
    }

    cout << "Starting Semantic Analysis..." << endl;
    std::set<std::string> declaredVars; // âœ… Ensure the declaredVars set is passed

    int methodBodyLine ;  
    //checkForDuplicateIdentifiers(root, table);
    //detectInvalidArrayOperations(root, table, "", "");
    //detectUndefinedIdentifiers(root, table, "", "", declaredVars);
    //detectInvalidReturnTypes(root, table, " ", "", methodBodyLine);
    cout << "Semantic Analysis Complete!" << endl;
}

void detectInvalidReturnTypes(Node* node, SymbolTable& table, string currentClass, string currentMethod, int& methodBodyLine) {
    if (!node) return;

    if (node->type == "ClassDeclaration") {
        currentClass = node->value;
    }

    if (node->type == "MethodDeclaration") {
        currentMethod = node->value;
    }

    if (node->type == "MethodBody") {
        methodBodyLine = node->lineno;
    }

    if (node->type == "ReturnStatement") {
        string expectedReturnType = "Unknown";
        string actualReturnType = "void";

        SymbolRecord* methodRecord = table.lookupSymbol(currentMethod, currentClass);
        if (methodRecord) {
            expectedReturnType = methodRecord->type;
        } else {
            std::cerr << "@error at line " << methodBodyLine
                      << ". semantic (Method '" << currentMethod << "' not found in class '" << currentClass << "')" << std::endl;
            return;
        }

        if (!node->children.empty()) {
            Node* returnValue = node->children.front();
            actualReturnType = getExpressionType(returnValue, table, currentClass, currentMethod);
        }

        if (actualReturnType != expectedReturnType) {
            std::cerr << "@error at line " << methodBodyLine
                      << ". semantic (Invalid return type: expected " << expectedReturnType
                      << " but got " << actualReturnType << ")" << std::endl;
        }
    }

    for (Node* child : node->children) {
        detectInvalidReturnTypes(child, table, currentClass, currentMethod, methodBodyLine);
    }
}

string getExpressionType(Node* node, SymbolTable& table, string currentClass, string currentMethod) {
    if (!node) return "Unknown";

    if (node->type == "IntegerLiteral") return "int";
    if (node->type == "BooleanLiteral") return "boolean";

    if (node->type == "Identifier") {
        SymbolRecord* var = table.lookupSymbol(node->value, currentMethod);
        if (!var) var = table.lookupSymbol(node->value, currentClass);
        if (!var) return "Unknown";
        return var->type;
    }

    if (node->type == "MethodCall") {
        string methodName = node->value;
        SymbolRecord* method = table.lookupSymbol(methodName, currentClass);
        if (!method) return "Unknown";
        return method->type;
    }

    if (node->type == "ArrayAccess") {
        Node* arrayNode = node->children.front();
        string arrayType = getExpressionType(arrayNode, table, currentClass, currentMethod);
        return (arrayType == "int[]") ? "int" : "Unknown";
    }

    if (node->type == "ThisExpression") {
        return currentClass;
    }

    if (node->type == "NewObject") {
        return node->value;
    }

    return "Unknown";
}


void checkForDuplicateIdentifiers(Node* root, SymbolTable& table) {
    if (!root) return;

    static set<string> declaredClasses;

    if (root->type == "MainClass") {
        string className = root->value;

        if (declaredClasses.count(className)) {
            std::cerr << "@error at line " << root->lineno << ". semantic (Already Declared Class: '" << className << "')" << std::endl;
        } else {
            declaredClasses.insert(className);
        }
    }

    // Explicitly handle ClassDeclarations node
    if (root->type == "ClassDeclarations") {
        for (Node* classNode : root->children) {
            if (classNode->type == "ClassDeclaration") {
                string className = classNode->value;

                int declarationLine = classNode->lineno;
                if (!classNode->children.empty()) {
                    declarationLine = classNode->children.front()->lineno;
                }

                if (declaredClasses.count(className)) {
                    std::cerr << "@error at line " << declarationLine << ". semantic (Already Declared Class: '" << className << "')" << std::endl;
                } else {
                    declaredClasses.insert(className);
                }

                set<string> fieldNames;  
                set<string> methodNames;

                // Traverse class body for fields and methods
                for (Node* member : classNode->children) {
                    if (member->type == "ClassBody") {
                        for (Node* classMember : member->children) {
                            // Detect duplicate fields
                            if (classMember->type == "VarDeclaration") {
                                string varName = classMember->children.back()->value;
                                if (fieldNames.count(varName)) {
                                    std::cerr << "@error at line " << classMember->lineno << ". semantic (Already Declared variable: '" << varName << "')" << std::endl;
                                } else {
                                    fieldNames.insert(varName);
                                }
                            }

                           
                            
                            
                            // Detect duplicate methods
                            if (classMember->type == "MethodDeclaration") {
                                string methodName = classMember->value;

                                
                                int methodLine = classMember->lineno; 
                                for (Node* child : classMember->children) {
                                    if (child->type == "MethodBody") {
                                        methodLine = child->lineno;
                                        break;
                                    }
                                }

                                if (methodNames.count(methodName)) {
                                    std::cerr << "@error at line " << methodLine << ". semantic (Already Declared Function: '" << methodName << "')" << std::endl;
                                } else {
                                    methodNames.insert(methodName);
                                }
                                                        
                                set<string> localIdentifiers;
                            
                                for (Node* paramSection : classMember->children) {
                                    if (paramSection->type == "Parameters") {
                                        for (Node* param : paramSection->children) {
                                            if (param->type == "Parameter") {
                                                string paramName = param->children.front()->value;
                            
                                                if (localIdentifiers.count(paramName)) {
                                                    std::cerr << "@error at line " << param->lineno << ". semantic (Already Declared parameter: '" << paramName << "')" << std::endl;
                                                } else {
                                                    localIdentifiers.insert(paramName);
                                                }
                                            }
                                        }
                                    }
                                }
                            
                                
                                for (Node* bodySection : classMember->children) {
                                    if (bodySection->type == "MethodBody") {
                                        for (Node* stmt : bodySection->children) {
                                            if (stmt->type == "VarDeclaration") {
                                                string varName = stmt->children.back()->value;
                            
                                                if (localIdentifiers.count(varName)) {
                                                    std::cerr << "@error at line " << stmt->lineno << ". semantic (Already Declared parameter: '" << varName << "')" << std::endl;
                                                } else {
                                                    localIdentifiers.insert(varName);
                                                }
                                            }
                                        }
                                    }
                                }
                            
                            }
                        }
                    }
                }
            }
        }
    }
    


    // Recursively check child nodes
    for (Node* child : root->children) {
        checkForDuplicateIdentifiers(child, table);
    }
}








void detectInvalidArrayOperations(Node* node, SymbolTable& table, string currentClass, string currentMethod) {
    if (!node) return;

    if (node->type == "ArrayAccess" && node->children.size() >= 1) {
        Node* arrayNode = node->children.front();
        Node* indexNode = node->children.back();

        if (indexNode->type != "IntegerLiteral" && indexNode->type != "Identifier") {
            std::cerr << "@error at line " << node->lineno << ". semantic (Invalid type of array index)" << std::endl;
        }

        if (arrayNode->type != "Identifier") {
            std::cerr << "@error at line " << node->lineno << ". semantic (Invalid array access)" << std::endl;
        }
    }

    if (node->type == "ArrayLength" && !node->children.empty()) {
        Node* targetNode = node->children.front();
        string arrayType = getExpressionType(targetNode, table, currentClass, currentMethod);
        if (arrayType != "int[]") {
            std::cerr << "@error at line " << node->lineno << ". semantic (Member .length is used incorrectly)" << std::endl;
        }
    }

    for (Node* child : node->children) {
        detectInvalidArrayOperations(child, table, currentClass, currentMethod);
    }
}

//void checkForDuplicateIdentifiers(Node* root, SymbolTable& table, std::string currentClass) {  // âœ… No default value here
//    
//    if (!root) return;
//
//    // Handle MainClass
//    if (root->type == "MainClass") {
//        string className = root->value;
//
//        if (table.classes.count(className)) {
//            std::cerr << "@error at line " << root->lineno << ". semantic (Already Declared Class: '" << className << "')" << std::endl;
//        }
//    }
//
//    // Handle Class Declarations
//    if (root->type == "ClassDeclarations") {
//        for (Node* classNode : root->children) {
//            if (classNode->type == "ClassDeclaration") {
//                string className = classNode->value;
//
//                int declarationLine = classNode->lineno;
//                if (!classNode->children.empty()) {
//                    declarationLine = classNode->children.front()->lineno;
//                }
//
//                if (table.classes.count(className)) {
//                    std::cerr << "@error at line " << declarationLine << ". semantic (Already Declared Class: '" << className << "')" << std::endl;
//                }
//
//                // Set the current class for further checks
//                currentClass = className;
//
//                // Traverse class body for fields and methods
//                for (Node* member : classNode->children) {
//                    if (member->type == "ClassBody") {
//                        for (Node* classMember : member->children) {
//                            // Detect duplicate fields
//                            if (classMember->type == "VarDeclaration") {
//                                string varName = classMember->children.back()->value;
//                                if (table.classes[currentClass].fields.count(varName)) {
//                                    std::cerr << "@error at line " << classMember->lineno 
//                                              << ". semantic (Already Declared variable: '" << varName << "')" << std::endl;
//                                }
//                            }
//
//                            // Detect duplicate methods
//                            if (classMember->type == "MethodDeclaration") {
//                                string methodName = classMember->value;
//
//                                int methodLine = classMember->lineno; 
//                                for (Node* child : classMember->children) {
//                                    if (child->type == "MethodBody") {
//                                        methodLine = child->lineno;
//                                        break;
//                                    }
//                                }
//
//                                if (table.classes[currentClass].methods.count(methodName)) {
//                                    std::cerr << "@error at line " << methodLine 
//                                              << ". semantic (Already Declared Function: '" << methodName << "')" << std::endl;
//                                }
//
//                                string currentMethod = methodName; // Track method scope
//
//                                // Check method parameters
//                                for (Node* paramSection : classMember->children) {
//                                    if (paramSection->type == "Parameters") {
//                                        for (Node* param : paramSection->children) {
//                                            if (param->type == "Parameter") {
//                                                string paramName = param->children.front()->value;
//
//                                                if (table.classes[currentClass].methods[currentMethod].parameters.count(paramName)) {
//                                                    std::cerr << "@error at line " << param->lineno 
//                                                              << ". semantic (Already Declared parameter: '" << paramName << "')" << std::endl;
//                                                }
//                                            }
//                                        }
//                                    }
//                                }
//
//                                // Check local variables inside method body
//                                for (Node* bodySection : classMember->children) {
//                                    if (bodySection->type == "MethodBody") {
//                                        for (Node* stmt : bodySection->children) {
//                                            if (stmt->type == "VarDeclaration") {
//                                                string varName = stmt->children.back()->value;
//
//                                                if (table.classes[currentClass].methods[currentMethod].variables.count(varName)) {
//                                                    std::cerr << "@error at line " << stmt->lineno 
//                                                              << ". semantic (Already Declared variable: '" << varName << "')" << std::endl;
//                                                }
//                                            }
//                                        }
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }
//            }
//        }
//    }
//
//    // Recursively check child nodes
//    for (Node* child : root->children) {
//        checkForDuplicateIdentifiers(child, table, currentClass);
//    }
//}

void detectUndefinedIdentifiers(Node* node, SymbolTable& table, std::string currentClass, std::string currentMethod, std::set<std::string>& declaredVars) {
    if (!node) return;

    if (node->type == "ClassDeclaration") {
        currentClass = node->value;
    }

    if (node->type == "MethodDeclaration") {
        currentMethod = node->value;
    }

    if (node->type == "VarDeclaration") {
        string varName = node->children.back()->value;
        declaredVars.insert(varName);
    }

    if (node->type == "Assignment") {
        string varName = node->children.front()->value;

        if (declaredVars.count(varName)) return;

        if (!table.lookupSymbol(varName, currentMethod) &&
            !table.lookupSymbol(varName, currentClass)) {
            std::cerr << "@error at line " << node->lineno
                      << ". semantic ('" << varName << "' does not exist in the current scope)" << std::endl;
        }
    }

    if (node->type == "Identifier") {
        string varName = node->value;
        if (declaredVars.count(varName)) return;
        if (!table.lookupSymbol(varName, currentMethod) &&
            !table.lookupSymbol(varName, currentClass)) {
            std::cerr << "@error at line " << node->lineno
                      << ". semantic ('" << varName << "' does not exist in the current scope)" << std::endl;
        }
    }

    if (node->type == "MethodCall") {
        string methodName = node->value;
        if (!table.lookupSymbol(methodName, currentClass)) {
            std::cerr << "@error at line " << node->lineno
                      << ". semantic ('" << methodName << "' does not exist in class '" << currentClass << "')" << std::endl;
        }
    }

    for (Node* child : node->children) {
        detectUndefinedIdentifiers(child, table, currentClass, currentMethod, declaredVars);
    }
}
